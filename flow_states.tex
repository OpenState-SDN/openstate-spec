%!TEX root=000-main.tex

\chapter{Flow States}
\label{chap:flow_states}

\todo{??}{Refactoring. This section should contain an high level description of the necessary elements and primitives to handle flow states, no C struct nor protocol message specification should be given here. These should be included in the protocol section along with checks and errors.}

A flow-state is an information associated to a flow and shared among all the flow's packets. Flows are uniquelly defined by the lookup-scope and update-scope. TBC.

\section{State Table}

\todo{??}{

Describe the state table in terms of:
    \begin{itemize}
        \item columns (key, state label, timeouts, counters?)
        \item exact match
        \item table-miss (DEFAULT vs NULL)
        \item timeouts
    \end{itemize}
}

In case of table-miss (the key is not matched) then a \texttt{DEFAULT} state will be appended to the packet headers.

\subsection{Key Extractor}

\todo{??}{
Describe the key extractor in terms of:
    \begin{itemize}
        \item difference between lookup/update (we should discuss, see next comment)
        \item vector of header fields
        \item header-miss (what if the specified header doesn't exist)
    \end{itemize}
}

\comment{Carmelo}{It seems that the only case where I need to declare two distinct lookup-scope/update-scope is when I need to update the state for the reverse flow (e.g. MAC learning, reverse path forwarding consistency, etc.). Would it be better to define just one flow-scope (essentially the lookup scope) and give the possibility to call a set-state on a transformation of this flow scope? Example: I define the flow-scope as f=\{ipsrc,ipdst\} and I define a reverse() function, that returns the definition of the reverse flow for the passed scope. In this case it would be reverse(f) = \{ipdst,ipsrc\} }

If the header fields specified by the lookup-scope are not found (e.g. extracting the IP source address when the Ethernet type is not IP) or are only partially found, a special state value \texttt{NULL} is returned and no information about state is appended to the packet.

\subsection{State Modification Messages}

\label{sec:msg_set_state}

State modification messages can have the following types:
\scriptsize\begin{verbatim}
enum ofp_state_mod_command {
    OFPSC_SET_L_EXTRACTOR = 0,
    OFPSC_SET_U_EXTRACTOR,
    OFPSC_ADD_FLOW_STATE,   
    OFPSC_DEL_FLOW_STATE
 };
\end{verbatim}\normalsize


\comment{Carmelo}{enum values are not defined for ofp\_state\_mod\_command}
\comment{Luca, Davide}{\textbf{To Carmelo:} An enumerator with no = defines its value by adding 1 to the value of the previous enumeration constant }

\noindent
To \textbf{setup the lookup extractor} the controller has to set the \texttt{OFPSC\_SET\_L\_EXTRACTOR} command in a state modification message. 
This command allows the controller to set the vector of lookup-scope's header fields used in the state table.
\\\\The controller can \textbf{setup the update extractor} by sending a state modification message with the \texttt{OFPSC\_SET\_U\_EXTRACTOR} command set.
This command gives the opportunity to set the vector of update-scope's header fields used in the state table.
\\\\To \textbf{add} or \textbf{update} a state entry in the state table, the controller has to send a state modification message with the \texttt{OFPSC\_ADD\_FLOW\_STATE} command set. This message is equivalent to the set state action \ref{sec:act_set_state}.
\\\\The controller can \textbf{delete} a state entry by means of a state modification message with the \texttt{OFPSC\_DEL\_FLOW\_STATE} command set. This command is equivalent to invoking a \texttt{OFPSC\_ADD\_FLOW\_STATE} command or a set state action \ref{sec:act_set_state} with \texttt{DEFAULT} state.

\comment{Luca, Davide}{There is a little difference between the delete command and a set state action with default state. The delete command removes the entry from the state table saving space, while by using a set state action with a DEFAULT state, the state entry is not removed. The two commands can be considered equivalent thanks to the fact that a default state will always be associated to an unknown flow.}




