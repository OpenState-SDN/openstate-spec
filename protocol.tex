%!TEX root=main.tex

\chapter{Protocol}
\label{chap:protocol}

\section{Capability}
\label{sec:capability}
\scriptsize
\begin{verbatim}
OFPC_OPENSTATE = 1 << 9   /* Capabilities supported by the datapath (add to enum ofp_capabilities) */
\end{verbatim}
\normalsize
\noindent
A new \texttt{OFPC\_OPENSTATE} capability has been introduced.
The basic flow table data structure has been extended with a support data structure implementing the state table (a hash map indexed by the flow key), the lookup and update key extractor (two ordered lists of flow match TLV field indexes) and the global states.
By retrieving all the capabilities from the switch, the controller is able to properly configure the switch. If a switch is OpenState aware, the \texttt{OFPC\_OPENSTATE} capability bit is set enabling the controller to configure the statefulness of each stage by sending table feature message [\ref{sec:table_conf}].

\section{Stage Configuration}
\label{sec:table_conf}
\scriptsize
\begin{verbatim}
 OFPTC_TABLE_STATEFUL = 1 << 4   /* (add to bitmap of OFPTC_* flags) */
\end{verbatim}
\normalsize
If \texttt{OFPTC\_TABLE\_STATEFUL} bit is set in the table features' config bitmap, right after the packet headers are parsed, the flow state is retrieved and written in the state field, otherwise the packet directly jumps to the flow table. 

\section{State Modification Messages}

\label{sec:msg_set_state_proto}

Modifications to the state table from the controller are done with the \texttt{OFPT\_STATE\_MOD} message:
\scriptsize
\begin{verbatim}
OFPT_STATE_MOD = 30     /* Controller to switch message  (add to enum ofp_type) */

struct ofp_state_mod {
    struct   ofp_header header;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t  table_id;
    uint8_t  command;
    uint8_t  payload[];
};
\end{verbatim}
\normalsize

\comment{Luca, Davide}{
From OpenFlow spec:
\textit{The cookie field is an opaque data value chosen by the controller. This value appears in flow removed
messages and flow statistics, and can also be used to filter flow statistics, flow modification and flow deletion. It is not used by the packet processing pipeline. When a flow entry is inserted in a table through an OFPFC\_ADD message, its cookie field is set to the provided value. When a flow entry is modified (OFPFC\_MODIFY or OFPFC\_MODIFY\_STRICT messages), its cookie field is unchanged.}

Why has it been included in the ofp\_state\_mod message?
}
\noindent
The \texttt{table\_id} field specifies the table to be modified (extractors setup or states modifications).
\\\\
The \texttt{command} field must be one of the following:
\scriptsize
\begin{verbatim}
enum ofp_state_mod_command {
    OFPSC_SET_L_EXTRACTOR = 0,
    OFPSC_SET_U_EXTRACTOR,
    OFPSC_ADD_FLOW_STATE,   
    OFPSC_DEL_FLOW_STATE
 };
\end{verbatim}
\normalsize
The differences between the four commands are explained in section \ref{sec:msg_set_state}.
\\\\
The \texttt{payload} field structure is defined by \texttt{ofp\_state\_entry} or \texttt{ofp\_extraction} according to the value of \texttt{command} field.
\\\\
An \texttt{OFPT\_STATE\_MOD} message with \texttt{command} field set to \texttt{OFPSC\_SET\_L\_EXTRACTOR} or \texttt{OFPSC\_SET\_U\_EXTRACTOR} must have a \texttt{payload} structure as defined by \texttt{ofp\_extraction}.
\scriptsize
\begin{verbatim}
#define OFPSC_MAX_FIELD_COUNT 6     /* Max number of fields that can be used to compose the key extractor vector*/

struct ofp_extraction {
    uint32_t field_count;
    uint32_t fields[OFPSC_MAX_FIELD_COUNT];
};
\end{verbatim}
\normalsize
The \texttt{field\_count} field specifies the number of fields provided in \texttt{fields[]}.
\\\\The \texttt{fields[]} field contains the vector of fields composing the key extractor.

\comment{Luca, Davide}{who decides OFPSC\_MAX\_FIELD\_COUNT and OFPSC\_MAX\_KEY\_LEN? Should they be configurable?}
\noindent
An \texttt{OFPT\_STATE\_MOD} message with \texttt{command} field set to \texttt{OFPSC\_ADD\_FLOW\_STATE} or \texttt{OFPSC\_DEL\_FLOW\_STATE} must have a \texttt{payload} structure as defined by \texttt{ofp\_state\_entry}.
\scriptsize
\begin{verbatim}
#define OFPSC_MAX_KEY_LEN 48    /* Number of bytes composing the state key */

struct ofp_state_entry {
    uint32_t key_len;
    uint32_t state;
    uint8_t  key[OFPSC_MAX_KEY_LEN];
};
\end{verbatim}
\normalsize
The \texttt{key\_len} field specifies the number of keys provided in \texttt{key[]} (it is the key size in byte).
\\\\
The \texttt{state} field contains the state to be inserted (or updated) in the state table. In case \texttt{command} field is set to \texttt{OFPSC\_DEL\_FLOW\_STATE}, the \texttt{state} field can take any value because only \texttt{key} field is used to delete the corresponding entry in the state table.
\\\\
The \texttt{key} field contains the key used to access the state table, splitted in bytes (e.g: ip 10.0.0.1 is stored as [10,0,0,1])


\comment{Carmelo}{OFPSC\_ADD\_FLOW\_STATE should be renamed in OFPSC\_SET\_FLOW\_STATE}

\paragraph{Checks and Errors}

\begin{itemize}
\item When \texttt{command} field is set to \texttt{OFPSC\_SET\_L\_EXTRACTOR} or \texttt{OFPSC\_SET\_U\_EXTRACTOR}, \texttt{field\_count} must be consistent with the number of fields provided in \texttt{fields[]} and should be always greater than 0, otherwise the switch must return an \texttt{ofp\_error\_msg} with \texttt{OFPET\_BAD\_REQUEST} type and \texttt{OFPBRC\_BAD\_LEN} code at message unpack time.
\comment{Carmelo}{Are both \texttt{OFPET\_BAD\_ACTION} and \texttt{OFPBAC\_BAD\_LEN} returned?}
\comment{Luca, Davide}{\textbf{To Carmelo:} An error message has a type (\texttt{OFPET\_BAD\_ACTION}) and a code (\texttt{OFPBAC\_BAD\_LEN}). }

\item When \texttt{command} field is set to \texttt{OFPSC\_ADD\_FLOW\_STATE} or \texttt{OFPSC\_DEL\_FLOW\_STATE}, \texttt{key\_count} field must be consistent with the number of keys provided in \texttt{key[]} and should be always greater than 0, otherwise 
the switch must return an \texttt{ofp\_error\_msg} with \texttt{OFPET\_BAD\_REQUEST} type and \texttt{OFPBRC\_BAD\_LEN} code at message unpack time.

\item When \texttt{command} field is set to \texttt{OFPSC\_ADD\_FLOW\_STATE} or \texttt{OFPSC\_DEL\_FLOW\_STATE}, \texttt{key\_count} field must be consistent with the number of fields of the update-scope (previously configured with an \texttt{OFPSC\_SET\_U\_EXTRACTOR} command). This check is performed at message execution time.
\comment{Luca, Davide}{Should we inform the controller about this error?}

\item According to OpenState specifications, lookup-scope and update-scope should provide keys with same length. This check should be performed by the switch when a message with \texttt{command} field set to \texttt{OFPSC\_SET\_L\_EXTRACTOR} or \texttt{OFPSC\_SET\_U\_EXTRACTOR} is received: if the other extractor has already been configured, the new extractor key must have the same length. This check is performed at message execution time.
\comment{Luca, Davide}{Should we inform the controller about this error?}

\item When \texttt{command} field is set to \texttt{OFPSC\_ADD\_FLOW\_STATE} or \texttt{OFPSC\_DEL\_FLOW\_STATE}, \texttt{stage\_id} field must have a value less or equal than the number of pipeline’s tables, otherwise the switch must return an \texttt{ofp\_error\_msg} with \texttt{OFPET\_BAD\_REQUEST} type and \texttt{OFPBRC\_BAD\_TABLE\_ID} code. This check is performed at message unpack time (since the number of table is fixed).

\end{itemize}

\section{Set-state Action}
\label{sec:act_set_state_proto}

The \texttt{OFPAT\_SET\_STATE} action allows to set flow-states in a particulare stage of the pipeline.\\The following structure describes the body of set-state action:

\scriptsize
\begin{verbatim}
OFPAT_SET_STATE = 28    /* New action type  (add to enum ofp_action_type) */

/* Action structure for OFPAT_SET_STATE. */
struct ofp_action_set_state {
    uint16_t type;
    uint16_t len;
    uint32_t state;
    uint8_t stage_id;
    uint8_t pad[7];    /* Align to 64-bits. */
};
OFP_ASSERT(sizeof(struct ofp_action_set_state) == 16);
\end{verbatim}
\normalsize
\noindent
The \texttt{type} field should be set to \texttt{OFPAT\_SET\_STATE}.
\\\\
The \texttt{len} field should be set to 16.
\\\\
The \texttt{state} field specifies the state to be inserted (or updated) in the state table.
\\\\
The \texttt{stage\_id} field specifies the target stage of the state update action.

\comment{Carmelo}{I think we should rename stage\_id into table\_id for consistency with the OpenFlow specification}
\comment{Luca, Davide}{\textbf{To Carmelo:} Since a stateful stage comprises a state table and a flow table, we used stage\_id because we are not referring to the single flow table (table\_id) but we are referring to the entire stateful stage.}

\subsection{Checks and Errors}

\begin{itemize}
\item Set-state action must be called only on stateful stage. This check is performed at action execution time because the flow-mod message with a set-state action could be received by the switch before configuring a stage as stateful. The important thing is that the stage is stateful at action execution time (since the number of table is fixed).
\comment{Luca, Davide}{Should we inform the controller about this error?}

\item Set-state action must be performed onto a stage with \texttt{stage\_id} less or equal than the number of pipeline’s tables, otherwise the switch must return an \texttt{ofp\_error\_msg} with \texttt{OFPET\_BAD\_REQUEST} type and \texttt{OFPBRC\_BAD\_TABLE\_ID} code. This check is performed at message unpack time (the number of table is fixed, so installing a flow with a wrong action does not make sense).
\end{itemize}

\subsection{Priority}

The actions in an action set are applied in the order specified in the OpenFlow specification, regardless of the order that
they were added to the set. The new \texttt{OFPAT\_SET\_STATE} action has to be executed with an higher priority with respect to the \texttt{OFPAT\_SET\_FIELD} action. Given an action set containing both a set field and a set state action, with this setting it is avoided that the set field modifies header fields used by the set state's update scope before the set-state action execution.

\comment{Carmelo}{What's the priority with regards to other actions such as output, drop, etc? I think we should explain this.}
\comment{Luca,Davide}{Assumption: we want to perform set-state action before some other action of the same stage alters its header fields. For example the pop/push actions could modify it. So, in order to avoid it, we should define the highest possible priority for the set-state action.
Is the assumption legitimate?
\\ What if we set the highest possible priority and we want to perform a set-state action on a packet modified by other actions? We would need two stages: the first modifies header fields and the other executes the set-state action.
}

\section{State Match Field}
\label{sec:match_state}

The \texttt{OXM\_OF\_STATE} field is the field used in the flow table to match on the state value defined in the virtual packet header field returned by a state table in a stateful stage. It is a 32 bit field.

\comment{Luca, Davide}{Does OXM\_OF\_STATE need to have a mask?}
\comment{Carmelo}{\textbf{To Luca, Davide:} I think yes, the state field should be maskable. An example use case could be matching on the second half of a MPLS label describing the ingress/egress switch. In the same way I propose to introduce the possibility to mask the state value in the set-state action.}
\scriptsize
\begin{verbatim}
/* Flow state field definition (oxm-match.h) */
#define OXM_OF_STATE OXM_HEADER     (0x8000, 41, 4)
\end{verbatim}
\normalsize

\section{Flag modification messages}
\label{section:flag_mod_msg}
The OFPT\_FLAG\_MOD message allow the controller to modify global states value.
\paragraph{Structures in ofsoftswitch13:}\mbox{}\\
\begin{verbatim}
OFPT_FLAG_MOD = 31,  /* Controller/switch message */

struct ofp_flag_mod {
    struct ofp_header header;
    uint32_t flag;
    uint32_t flag_mask;
    uint8_t command;
    uint8_t pad[7];                  /* Pad to 64 bits. */
};

enum ofp_flag_mod_command { 
    OFPSC_MODIFY_FLAGS = 0,
    OFPSC_RESET_FLAGS
};

\end{verbatim}

There are two message types.
\subsection{Modify flags command}
The OFPSC\_MODIFY\_FLAGS allows to modify global states values. The controller sends a OFPSC\_MODIFY\_FLAGS message with the following parameters:
\begin{itemize}
\setlength\itemsep{0em}
\item flag = flags value
\item flag\_mask = mask value
\item command = 0 (OFPSC\_MODIFY\_FLAGS)
\end{itemize}

\subsection{Reset flags command}
The OFPSC\_MODIFY\_FLAGS allows to reset global states to the default value (OFP\_GLOBAL\_STATES\_DEFAULT in openflow.h)
The controller sends a OFPSC\_MODIFY\_FLAGS message with the following parameters:
\begin{itemize}
\setlength\itemsep{0em}
\item flag = ANY
\item flag\_mask = ANY
\item command = 1 (OFPSC\_RESET\_FLAGS)
\end{itemize}

\section{Set flag action}
\label{section:set_flag_action}
The OFPAT\_SET\_FLAG action is used to set flags' value.
In the flow modification message, the controller defines the action with the following parameters:
\begin{itemize}
\setlength\itemsep{0em}
\item flag = flags value
\item mask = flags mask
\end{itemize}

\paragraph{Structures in ofsoftswitch13:}\mbox{}\\
\begin{verbatim}
OFPAT_SET_FLAG = 29,   /* Set a single flag value of the global state */

/* Action structure for OFPAT_SET_FLAG */
struct ofp_action_set_flag {
    uint16_t type; /* OFPAT_SET_FLAG */
    uint16_t len;  /* Length is 8. */
    uint32_t value; /* flag value */
    uint32_t mask;    /*flag mask*/
    uint8_t pad[4];   /* Align to 64-bits. */
};
OFP_ASSERT(sizeof(struct ofp_action_set_flag) == 16);
\end{verbatim}

\section{Flags match field}
\label{section:oxm_of_flags}

If a switch supports OpenState (flag OFPTC\_TABLE\_STATEFUL set), right after the packet headers are parsed, the global states are retrieved and written in the flags field. OXM\_OF\_FLAGS is a field with mask, so it is possible to match it either exactly or with wildcards. A 0 bit in the mask means i-th flags value is ``do not care'', while a 1 bit value means ``exact match''.

Definition in ofsoftswitch13 (oxm-match.h file)
\begin{verbatim}
/* Global States */
#define OXM_OF_FLAGS OXM_HEADER     (0x8000, 40, 4)
#define OXM_OF_FLAGS_W OXM_HEADER_W (0x8000, 40, 4)
\end{verbatim}
Example match:
\begin{verbatim}
flags=(4,5)
\end{verbatim}
This command allows to match over *****************************1*0 flags configuration (4 in binary is 100 and the mask 5 is 101 that is exact match on LSB 1 (0 value) and LSB 3 (1 value) and ``don’t care'' over all the other flags. In order to perform an exact match on flags value no mask is required.
\\Example match:
\begin{verbatim}
flags=4
\end{verbatim}
NB: this match is very differend from the previous one. With this command we are matching over 00000000000000000000000000000100 flags configuration, so it is an exact match.

