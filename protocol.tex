%!TEX root=main.tex

\chapter{Protocol}
\label{chap:protocol}

\section{Capability}
\label{sec:capability}
A new OFPC\_OPENSTATE capability has been introduced.
The basic flow table data structure has been extended with a support data structure implementing the state table (a hash map indexed by the flow key), the lookup and update key extractor (two ordered lists of flow match TLV field indexes) and the global states.
By retrieving all the capabilities from the switch, the controller is able to properly configure the switch. If a switch is OpenState aware, OFPC\_OPENSTATE capability is defined enabling the controller to configure the statefulness of each stage by sending table feature message [\ref{sec:table_conf}].

\section{Stage Configuration}
\label{sec:table_conf}
If OFPTC\_TABLE\_STATEFUL flag is set, right after the packet headers are parsed, the flow state is retrieved and written in the state field, otherwise the packet directly jumps to the flow table. 

\section{State Modification Messages}

\label{sec:msg_set_state}

OpenState defines four different types of \texttt{OFPT\_STATE\_MOD} messages: 
\begin{itemize}
\setlength\itemsep{0em}
\item \textbf{Set-lookup-extractor}: allows the controller to set the vector of header fields of the lookup-scope;
\item \textbf{Set-update-extractor}: allows the controller to set the vector of header fields of the update-scope;
\item \textbf{Set-flow-state command}: allows the controller to add/update a new row in the state table (equivalent to the set-state action);
\item \textbf{Delete-flow-state}: allows the controller to delete a row in the state table (equivalent to invoking a  set-flow-state command or a set-state action with \texttt{DEFAULT} state).
\end{itemize}

The structures used

\begin{verbatim}
/*
 * Controller to switch message  (add to enum ofp_type)
 */
OFPT_STATE_MOD = 30

/*
 * Max number of fields that can be used to compose
 * the key extractor vector.
 */
#define OFPSC_MAX_FIELD_COUNT 6

/*
 * Number of bytes composing the state key
 */
#define OFPSC_MAX_KEY_LEN 48


struct ofp_state_mod {
    struct   ofp_header header;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t  table_id;
    uint8_t  command;
    uint8_t  payload[];
};
\end{verbatim}

\comment{Luca, Davide}{
From OpenFlow spec:
\textit{The cookie field is an opaque data value chosen by the controller. This value appears in flow removed
messages and flow statistics, and can also be used to filter flow statistics, flow modification and flow deletion. It is not used by the packet processing pipeline. When a flow entry is inserted in a table through an OFPFC\_ADD message, its cookie field is set to the provided value. When a flow entry is modified (OFPFC\_MODIFY or OFPFC\_MODIFY\_STRICT messages), its cookie field is unchanged.}

Why has it been included in the ofp\_state\_mod message?
}

\begin{verbatim}
struct ofp_state_entry {
    uint32_t key_len;
    uint32_t state;
    uint8_t  key[OFPSC_MAX_KEY_LEN];
};

struct ofp_extraction {
    uint32_t field_count;
    uint32_t fields[OFPSC_MAX_FIELD_COUNT];
};

enum ofp_state_mod_command {
	OFPSC_SET_L_EXTRACTOR = 0,
	OFPSC_SET_U_EXTRACTOR,
	OFPSC_ADD_FLOW_STATE,	
	OFPSC_DEL_FLOW_STATE
 };

\end{verbatim}

\comment{Carmelo}{enum values are not defined for ofp\_state\_mod\_command}

\comment{Luca, Davide}{\textbf{To Carmelo:} An enumerator with no = defines its value by adding 1 to the value of the previous enumeration constant }

\comment{Luca, Davide}{who decides OFPSC\_MAX\_FIELD\_COUNT and OFPSC\_MAX\_KEY\_LEN? Should they be configurable?}

\subsubsection{Set-lookup-extractor command}
\label{subsec:set_l_extr}

The \texttt{OFPSC\_SET\_L\_EXTRACTOR} command gives the opportunity to set the lookup scope used in the state table.
The controller sends a \texttt{OFPT\_STATE\_MOD} message with the following parameters:

\begin{itemize}
\item table\_id = ID of the stage to be setup
\item command = 0 (\texttt{OFPSC\_SET\_L\_EXTRACTOR})
\item field\_count = number of specified field 
\item fields = key’s fields
\end{itemize}

\todo{Luca, Davide}{Include C struct of OFPSC\_SET\_L\_EXTRACTOR}
\comment{Luca, Davide}{A Set-lookup-extractor command is a ofp\_state\_mod message with command = 0 and struct ofp\_extraction as ofp\_state\_mod's payload}

\subsubsection{Set-update-extractor command}
\label{subsec:set_u_extr}

The OFPSC\_SET\_U\_EXTRACTOR command gives the opportunity to set the update scope used in the state table.
The controller sends a \texttt{OFPT\_STATE\_MOD} message with the following parameters:

\begin{itemize}
\item table\_id = ID of the stage to be setup
\item command = 1 (OFPSC\_SET\_U\_EXTRACTOR)
\item field\_count = number of specified field 
\item fields = key’s fields
\end{itemize}

\todo{Luca, Davide}{Include C struct of OFPSC\_SET\_U\_EXTRACTOR}
\comment{Luca, Davide}{A Set-update-extractor command is a ofp\_state\_mod message with command = 1 and struct ofp\_extraction as ofp\_state\_mod's payload}

\subsection{Set-flow-state command}
\label{subsec:add_flow}

The OFPSC\_ADD\_FLOW\_STATE command gives the opportunity to insert (or to overwrite) an entry in the state table.
The controller sends a \texttt{OFPT\_STATE\_MOD} message with the following parameters:

\begin{itemize}
\item table\_id = ID of the stage to be modified
\item command = 2 (OFPSC\_ADD\_FLOW\_STATE)
\item key\_count = it is the key size in byte
\item state = it is the state to insert in the state table
\item keys = key splitted in bytes (e.g: ip 10.0.0.1 is stored as [10,0,0,1])
\end{itemize}

\todo{Luca, Davide}{Include C struct of OFPSC\_ADD\_FLOW\_STATE}
\comment{Luca, Davide}{A Set-flow-state command is an ofp\_state\_mod message with command = 2 and struct ofp\_state\_entry as ofp\_state\_mod's payload}

\comment{Carmelo}{OFPSC\_ADD\_FLOW\_STATE should be renamed in OFPSC\_SET\_FLOW\_STATE}

\subsection{Delete-flow-state command}
\label{subsec:del_flow}

With the OFPSC\_DEL\_FLOW\_STATE command is possible to delete a state table's entry.
The controller sends a \texttt{OFPT\_STATE\_MOD} message with the following parameters:

\begin{itemize}
\item table\_id = ID of the stage to be modified
\item command = 3 (OFPSC\_DEL\_FLOW\_STATE)
\item key\_count = it is the key size in byte
\item state = ANY
\item keys = key splitted in bytes (e.g: ip 10.0.0.1 is stored as [10,0,0,1])
\end{itemize}

\todo{Luca, Davide}{Include C struct of OFPSC\_DEL\_FLOW\_STATE}
\comment{Luca, Davide}{A Delete-flow-state command is an ofp\_state\_mod message with command = 3 and struct ofp\_state\_entry as ofp\_state\_mod's payload}

The state value is not taken in consideration because the state table simply uses as key the lookup-scope's fields to delete the entry with key keys.

\paragraph{Checks and Errors}

\begin{itemize}
\item In Set-lookup-extractor/Set-update-extractor commands \texttt{field\_count} must be consistent with the number of fields (always greater than 0) provided in \texttt{fields[]}, otherwise an error (\texttt{OFPET\_BAD\_ACTION}, \texttt{OFPBAC\_BAD\_LEN}) is returned at message unpack time
\comment{Carmelo}{Are both \texttt{OFPET\_BAD\_ACTION} and \texttt{OFPBAC\_BAD\_LEN} returned?}
\comment{Luca, Davide}{\textbf{To Carmelo:} An error message has a type (\texttt{OFPET\_BAD\_ACTION}) and a code (\texttt{OFPBAC\_BAD\_LEN}): }

\item In Set-flow-state/Delete-flow-state commands \texttt{key\_count} must be consistent with the number of keys (always greater than 0) provided in \texttt{key[]}, otherwise an error (\texttt{OFPET\_BAD\_ACTION}, \texttt{OFPBAC\_BAD\_LEN}) is returned at msg unpack time. 

\item In Set-flow-state/Delete-flow-state commands \texttt{key\_count} must be consistent with the number of fields of the update-scope (defined before with a OFPSC\_SET\_U\_EXTRACTOR). This check is performed at msg execution time
\comment{Luca, Davide}{Should we inform the controller about this error?}

\item Lookup-scope and update-scope should provide same length keys. This check should be performed by the switch when a set-extractor message is received: if we have already set the other extractor, the new extractor must have the same length. The check is performed at msg execution time.
\comment{Luca, Davide}{Should we inform the controller about this error?}

\item Set-flow-state/Delete-flow-state commands must be executed onto a stage with stage\_id less or equal than the number of pipeline’s tables, otherwise the switch returns an error (OFPET\_BAD\_REQUEST, OFPBRC\_BAD\_TABLE\_ID). This check is performed at msg unpack time (since the number of table is fixed).

\end{itemize}

\section{Set-state Action}
\label{sec:act_set_state}

The \texttt{OFPAT\_SET\_STATE} action allows to set flow-states in a particulare stage of the pipeline.

The structure of the \texttt{OFPAT\_SET\_STATE} is defined in the following:

\begin{verbatim}
/* Action structure for OFPAT_SET_STATE. */
struct ofp_action_set_state {
    uint16_t type;     /* OFPAT_SET_STATE */
    uint16_t len;      /* Length is 16. */
    uint32_t state;    /* State value. */
    uint8_t stage_id;  /* Stage ID (same as flow table ID) of the state table */
    uint8_t pad[7];    /* Align to 64-bits. */
};
OFP_ASSERT(sizeof(struct ofp_action_set_state) == 16);
\end{verbatim}

\comment{Carmelo}{I think we should rename stage\_id into table\_id for consistency with the OpenFlow specification}
\comment{Luca, Davide}{\textbf{To Carmelo:} Since a stateful stage comprises a state table and and a flow table, we used stage\_id because we are not referring to the single flow table (table\_id) but we are referring to the entire stateful stage. }

\subsection{Atomicity}
As defined in OpenFlow, actions are usually executed at the end of the pipeline. The same applies for the \textbf{set-state} action, thus making the stateful steps ``lookup/update'' not atomic by default. Not enforcing atomicity can bring to consistency issues when more than one packet are processed by the pipeline at the same time. The only way to guarantees state consistency between packets is to call the \textbf{set-state} action from the \textbf{apply-action} instruction (instead of the \textbf{write-actions} instruction) in order to be sure to update the value contained in the state table when exiting a specific stage of the pipeline.

\subsection{Checks and Errors}

\begin{itemize}
\item Set-state action can be called only on stateful stage. This check is performed at action execution time (maybe the flow-mod message with a set-state action is received by the switch before configuring a stage as stateful. The important thing is that the stage is stateful at action execution time).
\comment{Luca, Davide}{Should we inform the controller about this error?}

\item Set-state action must be performed onto a stage with \texttt{stage\_id} less or equal than the number of pipeline’s tables. This check is performed at msg unpack time (the number of table is fixed, so installing a flow with a wrong action does not make sense).
\end{itemize}

\subsection{Priority}

The new \texttt{OFPAT\_SET\_STATE} action has to be executed with an higher priority with respect to the \texttt{OFPAT\_SET\_FIELD} action. Given an action set containing both a set field and a set state action, with this setting it is avoided that the set field modifies header fields used by the set state's update scope before the set state execution.

\comment{Carmelo}{What's the priority with regards to other actions such as output, drop, etc? I think we should explain this.}

\section{State Match Field}
\label{sec:match_state}

The \texttt{OXM\_OF\_STATE} field is the field used in the flow table to match on the state value defined in the virtual packet header field returned by a state table in a stateful stage. It is a 32 bit field.

\comment{Luca, Davide}{Does OXM\_OF\_STATE need to have a mask?}
\comment{Carmelo}{\textbf{To Luca, Davide:} I think yes, the state field should be maskable. An example use case could be matching on the second half of a MPLS label describing the ingress/egress switch. In the same way I propose to introduce the possibility to mask the state value in the set-state action.}

\begin{verbatim}
/* Flow state field definition (oxm-match.h) */
#define OXM_OF_STATE OXM_HEADER     (0x8000, 41, 4)
\end{verbatim}

\section{Flag modification messages}
\label{section:flag_mod_msg}
The OFPT\_FLAG\_MOD message allow the controller to modify global states value.
\paragraph{Structures in ofsoftswitch13:}\mbox{}\\
\begin{verbatim}
OFPT_FLAG_MOD = 31,  /* Controller/switch message */

struct ofp_flag_mod {
    struct ofp_header header;
    uint32_t flag;
    uint32_t flag_mask;
    uint8_t command;
    uint8_t pad[7];                  /* Pad to 64 bits. */
};

enum ofp_flag_mod_command { 
    OFPSC_MODIFY_FLAGS = 0,
    OFPSC_RESET_FLAGS
};

\end{verbatim}

There are two message types.
\subsection{Modify flags command}
The OFPSC\_MODIFY\_FLAGS allows to modify global states values. The controller sends a OFPSC\_MODIFY\_FLAGS message with the following parameters:
\begin{itemize}
\setlength\itemsep{0em}
\item flag = flags value
\item flag\_mask = mask value
\item command = 0 (OFPSC\_MODIFY\_FLAGS)
\end{itemize}

\subsection{Reset flags command}
The OFPSC\_MODIFY\_FLAGS allows to reset global states to the default value (OFP\_GLOBAL\_STATES\_DEFAULT in openflow.h)
The controller sends a OFPSC\_MODIFY\_FLAGS message with the following parameters:
\begin{itemize}
\setlength\itemsep{0em}
\item flag = ANY
\item flag\_mask = ANY
\item command = 1 (OFPSC\_RESET\_FLAGS)
\end{itemize}

\section{Set flag action}
\label{section:set_flag_action}
The OFPAT\_SET\_FLAG action is used to set flags' value.
In the flow modification message, the controller defines the action with the following parameters:
\begin{itemize}
\setlength\itemsep{0em}
\item flag = flags value
\item mask = flags mask
\end{itemize}

\paragraph{Structures in ofsoftswitch13:}\mbox{}\\
\begin{verbatim}
OFPAT_SET_FLAG = 29,   /* Set a single flag value of the global state */

/* Action structure for OFPAT_SET_FLAG */
struct ofp_action_set_flag {
    uint16_t type; /* OFPAT_SET_FLAG */
    uint16_t len;  /* Length is 8. */
    uint32_t value; /* flag value */
    uint32_t mask;    /*flag mask*/
    uint8_t pad[4];   /* Align to 64-bits. */
};
OFP_ASSERT(sizeof(struct ofp_action_set_flag) == 16);
\end{verbatim}

\section{Flags match field}
\label{section:oxm_of_flags}

If a switch supports OpenState (flag OFPTC\_TABLE\_STATEFUL set), right after the packet headers are parsed, the global states are retrieved and written in the flags field. OXM\_OF\_FLAGS is a field with mask, so it is possible to match it either exactly or with wildcards. A 0 bit in the mask means i-th flags value is ``do not care'', while a 1 bit value means ``exact match''.

Definition in ofsoftswitch13 (oxm-match.h file)
\begin{verbatim}
/* Global States */
#define OXM_OF_FLAGS OXM_HEADER     (0x8000, 40, 4)
#define OXM_OF_FLAGS_W OXM_HEADER_W (0x8000, 40, 4)
\end{verbatim}
Example match:
\begin{verbatim}
flags=(4,5)
\end{verbatim}
This command allows to match over *****************************1*0 flags configuration (4 in binary is 100 and the mask 5 is 101 that is exact match on LSB 1 (0 value) and LSB 3 (1 value) and ``don’t care'' over all the other flags. In order to perform an exact match on flags value no mask is required.
\\Example match:
\begin{verbatim}
flags=4
\end{verbatim}
NB: this match is very differend from the previous one. With this command we are matching over 00000000000000000000000000000100 flags configuration, so it is an exact match.

